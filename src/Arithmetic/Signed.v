Require Import ZArith Coq.Lists.List.
Local Open Scope Z_scope.
Local Open Scope list_scope.
From coqutil Require Import Byte Word.Naive Word.Interface Word.LittleEndianList.
Require Import bedrock2.BasicC64Semantics.
Require Import bedrock2.ZnWords Coq.ZArith.ZArith Lia.
From coqutil Require Import Tactics.Tactics Word.Properties Datatypes.List.
Import List.ListNotations.

Open Scope nat_scope.
Open Scope Z_scope.
Open Scope list_scope.
#[local] Coercion Z.of_nat: nat >-> Z.

(* This file proves the doubling case is never reached during point multiplication when using
signed limbs to encode the number. I.e. k*P where k is encoded in w-sized signed limbs.

We assume a limb size w, and a modulus N (the curve's group order).
The relevant lemma is at the very bottom of the file, everything else builds up to it.

This is a formal version of the corresponding proof in boringssl:
https://boringssl.googlesource.com/boringssl/+/refs/heads/main/crypto/fipsmodule/ec/util.cc.inc
The main differences to boringssl are:
- We do not assume our number is generated by any specific recoding algorithm, rather we look at an
  arbitrary number represented with signed limbs of a certain bound.
- Our proof is arithmetic instead of using bitwise logic, that is why it looks quite different. *)

(* Side Note: If you want to do multiplication with a group order or limb size that do not
fit these criteria, there is an alternative: You can chop off an additional bit by checking
if your number k is larger than N/2, and if it is, calculate k*P = (N-k)(-P) instead.
The lemmas in this file should be partially fit for the approach, but would need some adaptation. *)

(* Helper lemmas for lists. *)

Lemma last_cons {T} : forall (x y d : T) xs, last (x :: y :: xs) d = last (y :: xs) d.
Proof. reflexivity. Qed.

Lemma last_rev_hd {T} : forall (l : list T) (d : T), last (rev l) d = hd d l.
Proof. destruct l; intros; cbn; rewrite ?last_last; exact eq_refl. Qed.

(* Note: The '- 0' is intentionally preserved to exactly match the i=0 base case
   during induction in later proofs without requiring manual term manipulation. *)
Lemma skipn_last : forall l, l <> [] -> (skipn (length l - 0 - 1) l) =  [(last l 0)].
Proof.
  intros l H. induction l; [congruence|].
  destruct l; [reflexivity|].
  cbn in *. rewrite Nat.sub_0_r in IHl.
  apply IHl. congruence.
Qed.

Lemma skipn_repeat {T} x n (v : T) : skipn n (repeat v x) = (repeat v (x - n)%nat).
Proof.
  generalize dependent x. induction n; [intros; rewrite Nat.sub_0_r; cbn; reflexivity|].
  intros. destruct x; cbn; try rewrite IHn; reflexivity.
Qed.

Lemma skipn_nth_cons {A} : forall (l : list A) (n : nat) d,
  n < length l -> skipn n l = nth n l d :: skipn (S n) l.
Proof.
  induction l; intros n d Hlen; [cbn in *; lia|].
  destruct n; cbn in *; try reflexivity.
  apply IHl. lia.
Qed.

(* Little endian positional evaluation of a number. E.g. eval_positional 10 [1,2] = 21. *)
Definition eval_positional B : list Z -> Z :=
  fold_right (fun a s => a + B*s) 0.

Section Base.
Context {B : Z}. (* The base for number encoding, usually something like 2^w for a given limb size w.*)
#[local] Notation eval_positional := (eval_positional B).

Lemma eval_positional_cons h t :
  eval_positional (h :: t) = h + B*(eval_positional t).
Proof. reflexivity. Qed.

Lemma eval_positional_map_cons {T} (f : T -> Z) h t :
  eval_positional ((f h) :: (map f t)) = f h + B*(eval_positional (map f t)).
Proof. constructor. Qed.

Lemma eval_positional_nil : eval_positional nil = 0.
Proof. reflexivity. Qed.

Lemma eval_positional_app t1 t2 :
  eval_positional (t1 ++ t2) = eval_positional t1 + B^length t1 * eval_positional t2.
Proof.
  revert t2; induction t1 as [|? ? IH].
  { intros; cbn [app length eval_positional fold_right]; nia. }
  { intros; rewrite <- app_comm_cons, !eval_positional_cons, IH, length_cons.
    rewrite Nat2Z.inj_succ, Z.pow_succ_r; lia. }
Qed.

(* Helper lemmas to remove suffix/most significant zero limbs. *)

#[local] Fixpoint remove_prefix_zeroes (num : list Z) :=
  match num with
   | 0 :: num => remove_prefix_zeroes num
   | num => num
  end.

#[local] Definition remove_suffix_zeroes (num : list Z) := rev (remove_prefix_zeroes (rev num)).

#[local] Lemma remove_prefix_zeroes_split (num : list Z) :
  exists n : nat, num = repeat 0 n ++ remove_prefix_zeroes num.
Proof.
  induction num as [|h t [n IH]]; [exists 0%nat; reflexivity|].
  destruct (Z.eq_dec h 0) as [Heq | Hneq].
  { exists (S n). subst. cbn. rewrite <- IH. reflexivity. }
  { exists 0%nat.  destruct h; try reflexivity. lia. }
Qed.

#[local] Lemma remove_suffix_zeroes_split (num : list Z) :
  exists n : nat, num = (remove_suffix_zeroes num) ++ repeat 0 n.
Proof.
  pose proof (remove_prefix_zeroes_split (rev num)) as [n Hsplit].
  exists n.
  etransitivity; [symmetry; apply rev_involutive|].
  rewrite Hsplit. unfold remove_suffix_zeroes.
  rewrite rev_app_distr, rev_repeat. reflexivity.
Qed.

#[local] Lemma Forall_remove_suffix_zeroes P num :
  Forall P num -> Forall P (remove_suffix_zeroes num).
Proof.
  intros H.
  pose proof (remove_suffix_zeroes_split (num)) as [n Hsplit].
  rewrite Hsplit in H. apply Forall_app in H. apply H.
Qed.

#[local] Lemma eval_positional_repeat_0 x :
  eval_positional (repeat 0 x) = 0.
Proof.
  induction x; cbn; nia.
Qed.

#[local] Lemma eval_positional_app_repeat_0 (num : list Z) x :
  eval_positional (num ++ repeat 0 x) = eval_positional num.
Proof.
  induction num; [apply eval_positional_repeat_0|].
  rewrite <- app_comm_cons, !eval_positional_cons, IHnum. reflexivity.
Qed.

#[local] Lemma eval_positional_suffix_zeroes_id (num : list Z) :
  eval_positional (remove_suffix_zeroes num) = eval_positional num.
Proof.
  destruct (remove_suffix_zeroes_split num) as [n Hsplit].
  rewrite Hsplit at 2.
  symmetry; apply eval_positional_app_repeat_0.
Qed.

#[local] Lemma hd_remove_prefix_zeroes_ineq_0 (num : list Z) :
  eval_positional num <> 0 ->
  hd 0 (remove_prefix_zeroes num) <> 0.
Proof.
  intros.
  induction num as [|a num IHnum]; [cbn; trivial|].
  destruct (Z.eq_dec a 0) as [Heq | Hneq].
  { subst. cbn. apply IHnum. rewrite eval_positional_cons in *. lia. }
  { cbn. destruct a; try lia; cbv [hd]; assumption. }
Qed.

#[local] Lemma last_remove_suffix_zeroes_ineq_0 (num : list Z) :
  eval_positional num <> 0 ->
  last (remove_suffix_zeroes num) 0 <> 0.
Proof.
  unfold remove_suffix_zeroes.
  rewrite last_rev_hd. rewrite <- (rev_involutive num) at 1.
  induction (rev num) as [|a l IHl].
  { intros Heval Hhd. apply Heval. reflexivity. }
  { intros Heval. destruct (Z.eq_dec a 0) as [Heq|Hneq]; subst.
    { cbn. apply IHl. intros Hl. apply Heval. cbn. rewrite eval_positional_app.
      cbn. lia. }
    { destruct a; cbn; lia. }
  }
Qed.

End Base.

#[local] Lemma pow_m1 x : x > 0 -> 2 ^ x = 2 * 2 ^ (x - 1).
Proof.
  intros.
  replace x with (x - 1 + 1) at 1 by lia.
  rewrite Z.pow_add_r; lia.
Qed.

Section Limbs.
Context {w : Z}.
Context {w_pos : w > 0}.
(* Limb bounds, multiplied by 2 to make them easier to use. *)
#[local] Notation signed_limb_bounded l := (-2^w + 2 <= 2*l <= 2^w) (only parsing).
#[local] Notation eval := (eval_positional (2^w)).

#[local] Lemma signed_limb_bounded_alt l : signed_limb_bounded l -> (-2^(w-1) + 1 <= l <= 2^(w-1)).
Proof. rewrite pow_m1; lia. Qed.

(* Sign of the highest non-negative limb determines the sign of the whole number. *)
#[local] Lemma highest_negative_implies_all_negative : forall (num : list Z),
  0 > (last num 0) -> Forall (fun b => signed_limb_bounded b) num ->
  eval num < 0.
Proof.
  induction num; [cbn; intros; lia|].
  destruct num; [cbn; intros; lia|].
  rewrite last_cons.
  intros H F. rewrite eval_positional_cons.
  apply invert_Forall_cons in F. destruct F as [A F].
  specialize (IHnum H F). nia.
Qed.

(* If a number is positive, then the highest nonzero limb is positive *)
#[local] Lemma positional_positive_last_positive : forall (num : list Z),
  Forall (fun b => signed_limb_bounded b) num ->
  0 < eval num ->
  0 < eval [(last (remove_suffix_zeroes num) 0)].
Proof.
  intros.
  apply Znot_ge_lt. intros P.
  unshelve epose proof (highest_negative_implies_all_negative
      (remove_suffix_zeroes num) _ _) as Hneg.
  { cbv [eval_positional fold_right map] in P.
    rewrite Z.mul_0_r, Z.add_0_r in P.
    unshelve epose proof (@last_remove_suffix_zeroes_ineq_0 (2^w) num _) as Hlast; try lia.
  }
  { apply Forall_remove_suffix_zeroes; assumption. }
  rewrite eval_positional_suffix_zeroes_id in Hneg.
  lia.
Qed.

(* If the last limb is positive then every non-empty suffix of the number is positive. *)
#[local] Lemma last_positive_all_suffix_positive : forall (num : list Z),
  Forall (fun b => signed_limb_bounded b) num ->
  0 < eval [(last num 0)] ->
  forall i : nat,
  i < (length num) ->
  0 < eval (skipn (length num - i - 1) num).
Proof.
  induction i; intros Hlen.
  { rewrite skipn_last; try lia.
    destruct num; [ cbn in *; lia | congruence ]. }
  { rewrite skipn_nth_cons with (d:=0) by lia.
    rewrite eval_positional_cons.
    assert (signed_limb_bounded (nth (length num - S i - 1) num 0))
      by (apply (Forall_In H); apply nth_In; lia).
    replace (S (length num - S i - 1))%nat with (length num - i - 1)%nat in * by lia.
    nia. }
Qed.

(* If the whole number is positive, then every suffix of it is non-negative.*)
#[local] Lemma num_positive_suffix_non_negative : forall (num : list Z),
  Forall (fun b => signed_limb_bounded b) num ->
  0 < eval num ->
  forall i : nat, i <= length num ->
  0 <= eval (skipn i num).
Proof.
  intros.
  pose proof (remove_suffix_zeroes_split num) as [n NumSplit].

  (* Destruct to decide if our accumulator is only suffix zeroes or not. *)
  destruct (Z.lt_decidable i (length (remove_suffix_zeroes num))).
  (* Case 1: A non-zero limb stays, that means the whole thing is positive. *)
  {
    unshelve epose proof (last_positive_all_suffix_positive (remove_suffix_zeroes num) _ _ ((length (remove_suffix_zeroes num) - i - 1)) _) as HPos.
    { apply Forall_remove_suffix_zeroes; assumption. }
    { apply positional_positive_last_positive; assumption. }
    { lia. }

    rewrite NumSplit, skipn_app.
    replace (i - length (remove_suffix_zeroes num))%nat with 0%nat by lia.
    rewrite skipn_O, eval_positional_app_repeat_0.
    replace i with (length (remove_suffix_zeroes num) - (length (remove_suffix_zeroes num) - i - 1) - 1)%nat by lia. lia.
  }
  (* Case 2: We skip the whole content, only zeroes left. *)
  {
    rewrite NumSplit, skipn_app.
    rewrite (skipn_all i (remove_suffix_zeroes num)); try lia.
    rewrite app_nil_l, skipn_repeat.
    rewrite eval_positional_repeat_0.
    lia.
  }
Qed.

(* General upper bound for number interpretation. It overshoots a bit, but good enough for us. *)
#[local] Lemma limb_bounds_num (num : list Z) :
  Forall (fun b => signed_limb_bounded b) num ->
  eval num < (2^w)^(length num).
Proof.
  intros.
  induction num; [cbn; lia|].
  rewrite eval_positional_cons.
  apply invert_Forall_cons in H. destruct H as [Hl Ha].
  apply IHnum in Ha.
  rewrite length_cons.
  replace (Z.of_nat (S (length num))) with ((length num) + 1) by lia.
  replace ((2^w) ^ ((length num) + 1)) with ((2^w) * (2^w) ^ (length num)) by
    (rewrite Z.pow_add_r; lia).
  nia.
Qed.

Section GroupOrder.
Context {N : Z}.
Context {n_large : N > 2^w}.
(* There is a distance between any multiple of 2^w and N that is larger than a limb can be.
Equivalent to the bit at w-1 of N being set. *)
Context {N_w_dist : ~(exists l x, 0 <= 2*l <= 2^w - 2 /\ x * 2^w + l = N)}.
(* The highest bit is not set in N, encoded in signed limbs of size w. *)
Context {N_leaves_room : (Z.log2 N) / w = (Z.log2 N + 1) / w}.

(* Number of limbs to represent numbers up to N.
If we did not have N_leaves_room, this would be ((Z.log2 N + 1) / w + 1). *)
#[local] Notation num_limbs := (Z.log2 N / w + 1) (only parsing).

(* Assuming we stay positive and below N, the intermediate scalar never equals the current limb. *)
#[local] Lemma positional_mod_ineq_least_bit (num : list Z) (limb : Z) :
  signed_limb_bounded limb -> 0 < eval (limb :: num) < N ->
  (2^w * eval num) mod N <> limb mod N.
Proof.
  intros Hlimb ?.
  rewrite Z.cong_iff_0, Z.mod_divide by lia.
  intros [x Heq].
  rewrite eval_positional_cons in *.
  assert (Hxn: x = 0 \/ x = 1) by nia.
  destruct Hxn; subst x.
  { apply Zminus_eq in Heq.
    enough (limb = 0) by lia.
    assert (Hmod: (2^w | limb)).
    { exists (eval num). lia. }
    destruct Hmod as [k Hk].
    assert (k = 0) by nia.
    lia. }
  { apply N_w_dist.
    pose proof (pow_m1 w w_pos).
    exists (-limb), (eval num).
    lia. }
Qed.

#[local] Lemma bitlength_N_not_div_w : ~ (w | Z.log2 N + 1).
Proof.
  intros [m H].
  rewrite H in N_leaves_room.
  rewrite Z_div_mult in N_leaves_room; try lia.
  rewrite <- N_leaves_room in H.
  pose proof (Z.mul_div_le (Z.log2 N) w);
  lia.
Qed.

#[local] Lemma w_le_log2N : w <= Z.log2 N.
Proof. apply Z.log2_le_pow2; lia. Qed.

#[local] Lemma N_not_power_of_2 : (2 ^ Z.log2 N < N).
Proof.
  apply Z.nle_gt.
  intros Neq.
  apply N_w_dist.
  assert (2^0 < 2^w) by (apply Z.pow_lt_mono_r; lia).
  pose proof w_le_log2N.
  exists 0, (2^((Z.log2 N)-w)).
  split; try lia.
  rewrite <-Z.pow_add_r by lia.
  epose proof (Z.log2_spec N).
  rewrite Z.sub_simpl_r.
  lia.
Qed.

#[local] Lemma upper_bound_suffix_is_N (num : list Z) :
  Forall (fun b => signed_limb_bounded b) num ->
  Z.of_nat (length num) <= num_limbs - 2 ->
  2^w * eval num < N.
Proof.
  intros.
  destruct num as [|z num']; [cbn; lia|].

  assert (Hlen : 0 < length (z :: num')) by (cbn; lia).

  assert (Hupper : eval (z :: num') < (2 ^ w) ^ (Z.log2 N / w + 1 - 2)).
  { eapply Z.lt_le_trans.
    { apply limb_bounds_num, H. }
    { assert (2^0 < 2^w) by (apply Z.pow_lt_mono_r; lia).
      apply Z.pow_le_mono_r; lia. } }

  rewrite <- Z.pow_mul_r in * by lia.
  rewrite Z.mul_sub_distr_l in *.
  replace ((w * (Z.log2 N / w + 1)) - w * 2) with (w * (Z.log2 N / w - 1)) in * by lia.

  apply (Zmult_lt_compat_l _ _ (2^w)) in Hupper; try lia.
  etransitivity; [exact Hupper|].

  assert ((Z.log2 N / w - 1) > 0) by lia.
  rewrite <- Z.pow_add_r; try nia.
  replace ((w + w * (Z.log2 N/ w - 1))) with (w * (Z.log2 N / w)) by lia.

  pose proof w_le_log2N.
  destruct (Znumtheory.Zdivide_dec w (Z.log2 N)) as [[x Hx] | Hndiv].
  { rewrite Hx.
    eapply Z.le_lt_trans.
    2: { apply N_not_power_of_2. }
    apply Z.pow_le_mono_r; try lia.
    rewrite Z.mul_div_le; lia. }
  { epose proof (Z.log2_spec N).
    etransitivity; [|apply N_not_power_of_2].
    apply Z.pow_lt_mono_r; try lia.
    apply Z.nle_gt. intros Neq. apply Hndiv.
    exists (Z.log2 N / w).
    pose proof (ZLib.Z.div_mul_undo_le (Z.log2 N) w).
    lia. }
Qed.

(* Combine everything into one lemma that proves there is never a doubling during scalar multiplication. *)
Lemma positional_skip_ineq_nth (i : nat) (num : list Z) :
  0 < i <= num_limbs ->
  length num = Z.to_nat num_limbs ->
  Forall (fun b => signed_limb_bounded b) num ->
  0 < eval num < N ->
  ~ ((nth (i-1) num 0) = 0 /\ eval (skipn i num) = 0) ->
  2^w * eval (skipn i num) mod N <> (nth (i-1) num 0) mod N.
Proof.
  intros. destruct i; [lia|].
  unshelve epose proof (num_positive_suffix_non_negative num _ _ (S i) _); try assumption; try lia.

  set (nth (S i - 1) num 0) as limb in *.
  set (skipn (S i) num) as accumulator in *.

  assert (signed_limb_bounded limb). { apply Forall_nth; [assumption|lia]. }

  destruct i. {
    destruct num. { rewrite length_nil in *. lia. }
    apply positional_mod_ineq_least_bit; [assumption|].
    cbn in *. assumption.
  }
  {
    unshelve epose proof (upper_bound_suffix_is_N accumulator _ _).
    { apply Forall_skipn. assumption. }
    { subst accumulator. rewrite !length_skipn; lia. }

    destruct (Z.eq_dec limb 0). {
      destruct (Z.eq_dec (eval accumulator) 0); try lia.
      rewrite !Z.mod_small by lia. lia.
    }

    destruct (Z.eq_dec (eval accumulator) 0). {
      rewrite Z.cong_iff_0.
      rewrite Z.mod_divide; [ | lia ].
      intros [x].
      destruct (Z.eq_dec x 0); nia.
    }

    destruct (Z_ge_lt_dec limb 0). { rewrite !Z.mod_small; nia. }

    apply positional_mod_ineq_least_bit; try assumption.
    rewrite eval_positional_cons; nia.
  }
Qed.

End GroupOrder.
End Limbs.
